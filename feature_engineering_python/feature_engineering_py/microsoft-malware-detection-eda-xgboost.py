#!/usr/bin/env python
# coding: utf-8

# # Microsoft Malware Detection
# ## EDA and *ML* in progress
# 
# ![](https://zeroproject.org/wp-content/uploads/2018/05/Microsoft.png)
# 
# ![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRbuYMzpgoRh2tLUj_EVV0z7gtIKwfJfZ7G-DP5dscAvSqcgSR_OQ)
# 
# The malware industry continues to be a well-organized, well-funded market dedicated to evading traditional security measures. Once a computer is infected by malware, criminals can hurt consumers and enterprises in many ways.With more than one billion enterprise and consumer customers, Microsoft takes this problem very seriously and is deeply invested in improving security. As one part of their overall strategy for doing so, Microsoft is challenging the data science community to develop techniques to predict if a machine will soon be hit with malware. As with their previous, Malware Challenge (2015), Microsoft is providing Kagglers with an unprecedented malware dataset to encourage open-source progress on effective techniques for predicting malware occurrences.
# 
# ### Goals
# The goal of this competition is to predict a Windows machineâ€™s probability of getting infected by various families of malware, based on different properties of that machine. The telemetry data containing these properties and the machine infections was generated by combining heartbeat and threat reports collected by Microsoft's endpoint protection solution, Windows Defender. Each row in this dataset corresponds to a machine, uniquely identified by a MachineIdentifier. HasDetections is the ground truth and indicates that Malware was detected on the machine. Using the information and labels in train.csv, you must predict the value for HasDetections for each machine in test.csv.
# 
# ### Metric
# Submissions are evaluated on area under the ROC curve between the predicted probability and the observed label.
# 
# #### Initial thanks and inspirations for this kernel - sources:
# - https://www.kaggle.com/theoviel/load-the-totality-of-the-data
# - https://www.kaggle.com/artgor/is-this-malware-eda-fe-and-lgb-updated
# 
# ## Table of Contents
# 1. [Importing the Dataset](#importing_the_dataset)
# 2. [Inspecting the Dataset](#inspecting)
# 3. [Exploratory Data Analysis](#EDA)
# 4. [Machine Learning Modeling](#ML)
# 
# ## ToDo: 
# - add more comments
# - Conclusion for Univariate, Bivariate and Multivariate plots
# - Dive into Feature Engineering
# - Experiments with NA_rate threshold, eta, number of estimators and xgboost parameters in general to improve auc
# 
# ### Summary of Versions:
# Until Version 22 I was playing around with EDA and trying to visualize as information as possible, unfortuately due to the enormous train set size which is almost 8GB I was working mainly with samples and trying to find ways to visualize as much information as I can. From version 22 and later versions of this Kernel, I was experimenting with Baseline XGboost and trying to find the optimal parameters via tuning. Feature Engineering still missing due to the fact that I dive into so much to tuning and trying to improve the classifier's performance and lost focus on other subjects but I will come back to that later. Tuning causes Kaggle to terminate my kernels due to timeout limitations. From Version #61 and so on I work with XGBoost classifers with optimal parameters found from my previous kernels. After the end of the competition and with the reveal of the private dataset, I am starting to suspect that my final tuned models are a bit overfitted and have to generalize.
# 
# #### Version History:
# - Version 22, with 90% na_rate threshold, 10% train_sample / Public score: ** 0.656 **
# - Version 23, with 90% na_rate threshold, 15% train_sample / Public score: ** 0.654 **
# - Version 24, with 80% na_rate threshold, 15% train_sample / Public score: ** 0.655 **
# - Version 25, with 80% na_rate threshold, 10% train_sample with better xgboost params / Public score: ** 0.661 **
# - Version 26, with 80% na_rate threshold, 10% train_sample with better xgboost params / Public score: ** 0.661 **
# - Version 27, with 70% na_rate threshold, 10% train_sample with better xgboost params eta: 0.1, 1000 estimators / Public score: ** 0.669 **
# - Version 28, with 70% na_rate threshold, 10% train_sample with better xgboost params eta: 0.05, 1000 estimators / Public score: ** 0.674 **
# - Version 29, with 70% na_rate threshold, 10% train_sample with better xgboost params eta: 0.05, 2000 estimators / Public score: ** 0.669 **
# - Version 30, with 60% na_rate threshold, 10% train_sample with better xgboost params eta: 0.05, 1000 estimators / Public score: ** 0.670 **
# - Version 31, with 60% na_rate threshold, 10% train_sample with better xgboost params eta: 0.05, 2000 estimators / Public score: ** 0.672 **
# - Version 32, with 50% na_rate threshold, 10% train_sample with better xgboost params eta: 0.05, 1000 estimators / Public score: ** 0.666 **
# - Version 33-34, with 70% na_rate threshold, 10% train_sample with better xgboost params eta: 0.1, 1000 estimators / Public score: ** 0.674 **
# - Version 35-36-37, with 70% na_rate threshold, 10% Introducing Feature Engineering, with train_sample and with better xgboost params eta: 0.1, 1000 estimators / score: ** 0.659 ** 
# - Version 38, with 70% na_rate threshold, 10% train_sample and with better xgboost params eta: 0.1, 1000 estimators and tuning / score: ** 0.671 **
# - Version 39-40, with 70% na_rate threshold, 10% train_sample and with better xgboost params eta: 0.1, 1000 estimators and tuning / score: ** 0.670 **
# - Version 41, with 70% na_rate threshold, 10% train_sample and with better xgboost params eta: 0.05, 2000 estimators and tuning / score: ** 0.673 ** 
# - Version 42-43-44, with 70% na_rate threshold, 10% train_sample and with better xgboost tuning / score: ** 0.677 **
# - Version 45, with 90% na_rate and unbalanced_features threshold, 12.5% train_sample and with better xgboost tuning / score: ** 0.664 IT HAS AN ERROR **
# - Version 46-47-48, with 90% na_rate and 90% unbalanced_features threshold, 12.5% train_sample and with xgboost tuning / score: ** TBA IT HAS AN ERROR **
# - Version 49, with 90% na_rate and 90% unbalanced_features threshold, 10% train_sample and with xgboost tuning / score: ** TBA, IT HAS AN ERROR **
# - Version 50, (Like Version 49) with 90% na_rate and 90% unbalanced_features threshold, 10% train_sample and with xgboost tuning / score: ** TBA, IT HAS AN ERROR  **
# - Version 51, with 70% na_rate and 90% unbalanced_features threshold, 10% train_sample and with xgboost tuning / score: ** TBA, IT HAS AN ERROR  **
# - Version 52, with 70% na_rate and 90% unbalanced_features threshold, 12.5% train_sample and with xgboost tuning / score: ** TBA, IT HAS AN ERROR **
# - Version 53, with 90% na_rate and 90% unbalanced_features threshold, 10% train_sample and with xgboost tuning / score: ** 0.673  **
# - Version 54, with 90% na_rate and 90% unbalanced_features threshold, 12.5% train_sample and with xgboost tuning / score: ** TBA,  running longer than 9h  **
# - Version 55, with 70% na_rate and 90% unbalanced_features threshold, 10% train_sample and with xgboost tuning / score: ** TBA, running longer than 9h  **
# - Version 56, with 70% na_rate and 90% unbalanced_features threshold, 12.5% train_sample and with xgboost tuning / score: ** TBA, running longer than 9h  **
# - Version 57, with 70% na_rate and 90% unbalanced_features threshold, 15% train_sample and with xgboost tuning / score: ** TBA, running longer than 9h  **
# - Version 58, with 70% na_rate and 90% unbalanced_features threshold, 18.5% train_sample and with xgboost tuning / score: ** TBA, running longer than 9h  **
# - Version 59, with 70% na_rate and 90% unbalanced_features threshold, 20% train_sample and with xgboost tuning / score: ** TBA, running longer than 9h  **
# - Version 60, with 70% na_rate and 90% unbalanced_features threshold, 10% train_sample and with xgboost tuning / score: ** TBA  **
# - Version 61, with 70% na_rate and 90% unbalanced_features threshold, 12.5% train_sample and with xgboost tuned / score: ** TBA  **
# - Version 62, with 70% na_rate and 90% unbalanced_features threshold, 15% train_sample and with xgboost tuned / score: ** TBA  **
# - Version 63, with 70% na_rate and 90% unbalanced_features threshold, 17.5% train_sample and with xgboost tuned / score: ** TBA, Exit with code -1  **
# - Version 64, with 70% na_rate and 90% unbalanced_features threshold, 20% train_sample and with xgboost tuned / score: ** TBA, Exit with code -1  **
# - Version 65, with 70% na_rate and 90% unbalanced_features threshold, 22.5% train_sample and with xgboost tuned / score: ** TBA, Exit with code -1  **
# - Version 66-67-68, with 70% na_rate and 90% unbalanced_features threshold, 25% train_sample and with xgboost tuned / score: ** TBA, Exit with code -1  **
# - Version 69, with 70% na_rate and 90% unbalanced_features threshold, 27.5% train_sample and with xgboost tuned / score: ** 0.674  **
# - Version 70, with 70% na_rate and 90% unbalanced_features threshold, 30% train_sample and with xgboost tuned / score: ** 0.675  **
# - Version 71-72-73, with 70% na_rate and 90% unbalanced_features threshold, 25% train_sample and with xgboost tuned and reduced reg_alpha and lambda / score: ** TBA  **
# - Version 74-75, with 70% na_rate and 90% unbalanced_features threshold, 27.5% train_sample and with xgboost tuned and reduced reg_alpha and lambda / score: ** TBA  **
# - Version 76, with 70% na_rate and 90% unbalanced_features threshold, 30% train_sample and with xgboost tuned and reduced reg_alpha and lambda / score: ** TBA  **
# - Version 77, with 70% na_rate and 90% unbalanced_features threshold, 32.5% train_sample and with xgboost tuned and reduced reg_alpha and lambda / score: ** 0.672  **
# - Version 78-79, Returning after the end of the competition to polish the Kernel, with 90% na_rate and 90% unbalanced_features threshold, 15% train_sample and with xgboost tuned / score: ** TBA  **
# 
# 
# ### Version Summary:
# Until Version 22 I was playing around with EDA and trying to visualize as information as possible, unfortuately due to the enormous train set size which is almost 8GB I was working mainly with samples and trying to find ways to visualize as much information as I can. From version 22 and later versions of this Kernel, I was experimenting with Baseline XGboost and trying to find the optimal parameters via tuning. Feature Engineering still missing due to the fact that I dive into so much to tuning and trying to improve the classifier's performance and lost focus on other subjects but I will come back to that later. Tuning causes Kaggle to terminate my kernels due to timeout limitations. From Version #61 and so on I work with XGBoost classifers with optimal parameters found from my previous kernels. Moreover, I am starting to believe that the 2 thresholds, na_rate and unbalanced_feature_rate_threshold must be both set to 0.9.
# 
# ### Thoughts about Feature Engineering:
# In order to know if a newly introduced feature may affect positevely or negatively the dataset I have to cross validate both with and without an xgboost model and measure its performance.
# 

# ## My train of thought is the following:
# The following Kernel Will perform:
# - Importing the dataset
# - EDA
# - Feature Engineering
# - Machine Learning Modeling
# 
# There is another Kernel for parameter tuning and another of blending CV predictions.
# 1. [XGBoost Tuning](https://www.kaggle.com/praxitelisk/microsoft-malware-detection-xgboost-tuning)
# 2. [XGBoost Blending CV Predictions](https://www.kaggle.com/praxitelisk/microsoft-malware-detection-xgboost-blends)
# 
# The order for Machine Learning predictions is as depicted from the flowchart:
# 1. Use this kernel for EDA, Feature Engineering and Baseline Modeling
# 2. Then tune the baseline model
# 3. Finally Blend Predictions from Cross Validations.

# <img src="data:image/png;base64,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" style="cursor:pointer;max-width:100%;" onclick="(function(img){if(img.wnd!=null&&!img.wnd.closed){img.wnd.focus();}else{var r=function(evt){if(evt.data=='ready'&&evt.source==img.wnd){img.wnd.postMessage(decodeURIComponent(img.getAttribute('src')),'*');window.removeEventListener('message',r);}};window.addEventListener('message',r);img.wnd=window.open('https://www.draw.io/?client=1&lightbox=1&edit=_blank');}})(this);"/>

# ### *Due to memory limitations both EDA and Machine Learning will be performed with a representative sample from the whole train set. Approximately 15% from the train set will be used for EDA and 15% sample from the whole train set will be used from ML modeling.*

# <a id="importing_the_dataset"></a>
# ## Importing the Dataset

# In[1]:


# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load in 

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)


# Input data files are available in the "../input/" directory.
# For example, running this (by clicking run or pressing Shift+Enter) will list the files in the input directory

import os
print(os.listdir("../input"))

import matplotlib
import matplotlib.pyplot as plt

import seaborn as sns

get_ipython().run_line_magic('matplotlib', 'inline')

plt.style.use('fivethirtyeight')

import time


# due to Kaggle memory limitations and the enormous dataset size, a sample from the whole
# trainset will be used for ML modeling
train_sample_fraction = None


# another global variable that must be defined is the NA values rate / theshold to ommit columns with
# NA values that pass this rate
na_rate_threshold = 0.9

# if we want to avoid using a fraction of the train dataset then using the following variable will suffice
train_sample_num = 1500000

# theshold to remove columns with unbalanced features to their values 
unbalanced_feature_rate_threshold = 0.9

# Any results you write to the current directory are saved as output.


# The data is quite big here, and all of it cannot be loaded at once with a simple read_csv call.
# A solution is to specify types, to gain memory (for example switching from float64 to float32)

# In[2]:


# I am grateful for the help of author of this kernel for the main idea to load the dataset and save memory space!!
# https://www.kaggle.com/theoviel/load-the-totality-of-the-data

dtypes = {
        'MachineIdentifier':                                    'category',
        'ProductName':                                          'category',
        'EngineVersion':                                        'category',
        'AppVersion':                                           'category',
        'AvSigVersion':                                         'category',
        'IsBeta':                                               'int8',
        'RtpStateBitfield':                                     'float16',
        'IsSxsPassiveMode':                                     'int8',
        'DefaultBrowsersIdentifier':                            'float16',
        'AVProductStatesIdentifier':                            'float32',
        'AVProductsInstalled':                                  'float16',
        'AVProductsEnabled':                                    'float16',
        'HasTpm':                                               'int8',
        'CountryIdentifier':                                    'int16',
        'CityIdentifier':                                       'float32',
        'OrganizationIdentifier':                               'float16',
        'GeoNameIdentifier':                                    'float16',
        'LocaleEnglishNameIdentifier':                          'int8',
        'Platform':                                             'category',
        'Processor':                                            'category',
        'OsVer':                                                'category',
        'OsBuild':                                              'int16',
        'OsSuite':                                              'int16',
        'OsPlatformSubRelease':                                 'category',
        'OsBuildLab':                                           'category',
        'SkuEdition':                                           'category',
        'IsProtected':                                          'float16',
        'AutoSampleOptIn':                                      'int8',
        'PuaMode':                                              'category',
        'SMode':                                                'float16',
        'IeVerIdentifier':                                      'float16',
        'SmartScreen':                                          'category',
        'Firewall':                                             'float16',
        'UacLuaenable':                                         'float32',
        'Census_MDC2FormFactor':                                'category',
        'Census_DeviceFamily':                                  'category',
        'Census_OEMNameIdentifier':                             'float16',
        'Census_OEMModelIdentifier':                            'float32',
        'Census_ProcessorCoreCount':                            'float16',
        'Census_ProcessorManufacturerIdentifier':               'float16',
        'Census_ProcessorModelIdentifier':                      'float16',
        'Census_ProcessorClass':                                'category',
        'Census_PrimaryDiskTotalCapacity':                      'float32',
        'Census_PrimaryDiskTypeName':                           'category',
        'Census_SystemVolumeTotalCapacity':                     'float32',
        'Census_HasOpticalDiskDrive':                           'int8',
        'Census_TotalPhysicalRAM':                              'float32',
        'Census_ChassisTypeName':                               'category',
        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',
        'Census_InternalPrimaryDisplayResolutionHorizontal':    'float16',
        'Census_InternalPrimaryDisplayResolutionVertical':      'float16',
        'Census_PowerPlatformRoleName':                         'category',
        'Census_InternalBatteryType':                           'category',
        'Census_InternalBatteryNumberOfCharges':                'float32',
        'Census_OSVersion':                                     'category',
        'Census_OSArchitecture':                                'category',
        'Census_OSBranch':                                      'category',
        'Census_OSBuildNumber':                                 'int16',
        'Census_OSBuildRevision':                               'int32',
        'Census_OSEdition':                                     'category',
        'Census_OSSkuName':                                     'category',
        'Census_OSInstallTypeName':                             'category',
        'Census_OSInstallLanguageIdentifier':                   'float16',
        'Census_OSUILocaleIdentifier':                          'int16',
        'Census_OSWUAutoUpdateOptionsName':                     'category',
        'Census_IsPortableOperatingSystem':                     'int8',
        'Census_GenuineStateName':                              'category',
        'Census_ActivationChannel':                             'category',
        'Census_IsFlightingInternal':                           'float16',
        'Census_IsFlightsDisabled':                             'float16',
        'Census_FlightRing':                                    'category',
        'Census_ThresholdOptIn':                                'float16',
        'Census_FirmwareManufacturerIdentifier':                'float16',
        'Census_FirmwareVersionIdentifier':                     'float32',
        'Census_IsSecureBootEnabled':                           'int8',
        'Census_IsWIMBootEnabled':                              'float16',
        'Census_IsVirtualDevice':                               'float16',
        'Census_IsTouchEnabled':                                'int8',
        'Census_IsPenCapable':                                  'int8',
        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',
        'Wdft_IsGamer':                                         'float16',
        'Wdft_RegionIdentifier':                                'float16',
        'HasDetections':                                        'int8'
        }

def reduce_mem_usage(df, verbose=True):
    numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']
    start_mem = df.memory_usage(deep=True).sum() / 1024**2    
    for col in df.columns:
        col_type = df[col].dtypes
        if col_type in numerics:
            c_min = df[col].min()
            c_max = df[col].max()
            if str(col_type)[:3] == 'int':
                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:
                    df[col] = df[col].astype(np.int8)
                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:
                    df[col] = df[col].astype(np.int16)
                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:
                    df[col] = df[col].astype(np.int32)
                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:
                    df[col] = df[col].astype(np.int64)  
            else:
                if c_min > np.finfo(np.float16).min and c_max < np.finfo(np.float16).max:
                    df[col] = df[col].astype(np.float16)
                elif c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:
                    df[col] = df[col].astype(np.float32)
                else:
                    df[col] = df[col].astype(np.float64)    
    end_mem = df.memory_usage(deep=True).sum() / 1024**2
    if verbose: print('Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)'.format(end_mem, 100 * (start_mem - end_mem) / start_mem))
    return df


# In[3]:


# to be deleted this cell
numerics = ['int8', 'int16', 'int32', 'int64', 'float16', 'float32', 'float64']
numerical_and_binary_columns = [c for c,v in dtypes.items() if v in numerics]


# In[4]:


get_ipython().run_cell_magic('time', '', "train = pd.read_csv('../input/train.csv', dtype=dtypes)\n")


# In[5]:


# Special thanks to https://www.kaggle.com/artgor/is-this-malware-eda-fe-and-lgb-updated
#train = reduce_mem_usage(train)


# <a id="inspecting"></a>
# ## Introductory Inspection for the train set and its features

# In[6]:


train.info()


# We can see that we have already a mix of numerical and categorical features.

# In[7]:


train.describe()


# We have a wide variety of data. most of them appear to have NaN values, we have to thoroughly inspect them.

# We have many features and lots of them have NA values, an idea is to ditch features that have many NA values bacause they do not provide any information that may be useful for the analysis.

# In[8]:


# special thanks to https://www.kaggle.com/artgor/is-this-malware-eda-fe-and-lgb-updated

stats = []
for col in train.columns:
    stats.append((col, train[col].dtype, train[col].nunique(), train[col].isnull().sum() * 100 / train.shape[0], train[col].value_counts(normalize=True, dropna=False).values[0] * 100))
    
stats_df = pd.DataFrame(stats, columns=['Feature', "type", 'Unique_values', 'Percentage of missing values', 'Percentage of values in the biggest category'])

stats_df.sort_values('Percentage of missing values', ascending=False)


# ### Remove columns with high * **NA** * rate threshold and high * **one category** * values only
# removing colums with NA rate more than * ** 70%** * threshold and * ** 90%  ** * features with one category only.

# In[9]:


good_cols = list(train.columns)

for col in train.columns:
    
    # remove columns with high NA rate
    na_rate = train[col].isnull().sum() / train.shape[0]
    
    # remove columns with high Unbalanced values rate
    unbalanced_rate = train[col].value_counts(normalize=True, dropna=False).values[0]
    
    if na_rate > na_rate_threshold:
        good_cols.remove(col)
    elif unbalanced_rate > unbalanced_feature_rate_threshold:
        good_cols.remove(col)


# In[10]:


good_cols


# In[11]:


print("train data set reduced size in memory:", train.memory_usage().sum() / (1000000000))


# In[12]:


train = train[good_cols]


# ### Delete some variables to free memory space.

# In[13]:


del stats_df


# ### Call garbage collector

# In[14]:


import gc

gc.collect()


# <a id="EDA"></a>
# ## Exploratory Data Analysis

# ![](http://blog.k2analytics.co.in/wp-content/uploads/2016/12/Exploratory_Data_Analysis.png)

# ### Let's print out and take a look at the header frame

# In[15]:


train.head()


# ### Train Set dimensions

# In[16]:


train.shape


# ### Target

# In[17]:


train['HasDetections'].value_counts()


# In[18]:


train['HasDetections'].value_counts().plot(kind="pie", figsize=(12,9), colormap="coolwarm")


# #### The target is balanced, which is nice.

# ### Seperate the categorical and the numerical columns in the Train Set
# MachineIdentifier is a unique ID and does not play any role to the analysis.

# In[19]:


categorical_columns = list(train.loc[:, train.dtypes =="category"].columns)
numerical_and_binary_columns = list(train.loc[:, train.dtypes !="category"].columns)
numerical_columns = numerical_and_binary_columns

categorical_columns.remove("MachineIdentifier")

binary_columns = []
for col in (numerical_and_binary_columns):
    if train[col].nunique() == 2:
        binary_columns.append(col)
        numerical_columns.remove(col)


# ### The Majority of types of features

# In[20]:


#print(len(categorical_columns))
#print(len(numerical_columns))
#print(len(binary_columns))

categories_list = []
categories_list.append(len(categorical_columns))
categories_list.append(len(numerical_columns))
categories_list.append(len(binary_columns))

categories_df = pd.DataFrame(categories_list, 
                             index=["categorical_features", "numerical_features", "binary_features"])

categories_df = categories_df.transpose().plot(kind="barh", figsize=(21, 10), title="number of different features")


# ### * Due to memory limitations, a small sample between 10% to 13% from the whole trainset will be used for Univariate, Bivariate and Multivariate plots *

# In[21]:


if train_sample_fraction is not None:
    train_sample = train.sample(frac=train_sample_fraction, random_state=42)
elif train_sample_num is not None:
    train_sample = train.sample(n=train_sample_num, random_state=42)
else:
    train_sample = train.sample(n=1500000, random_state=42)

gc.collect()


# In[22]:


categorical_columns


# ### Univariate Analysis - Barplots for the categorical features
# #### Inspecting each one of the categorical features from the train set and illustrating the top most occured categories per categorical feature against the *HasDetections* target variable. Moreover trying to fit a logistic regression model between the target variable and the inspected feature to identify if the feature is a good predictor.

# In[23]:


def categorical_univariate_and_bivariate_stats(feature):
    
    if feature in train_sample.columns:
    
        print("Top 10 most occurred categories for the categorical feature", feature)
        print(train_sample[feature].value_counts().head(10))

        f, axes = plt.subplots(1, 2, figsize=(21, 10))

        train_sample[feature].value_counts().head(10).plot.bar(ax=axes[0], colormap="BrBG")

        train_sample.groupby(["HasDetections", feature]).count()["MachineIdentifier"].unstack(0).sort_values(by=1, axis=0, ascending=False).head(10).plot.bar(ax=axes[1], colormap="coolwarm")
        
        f.suptitle("Categorical feature: "+" Univariate and Bivariate plots against the target variable")
        
    else:
        print("This feature has been removed from dataset due to high NaN rate or highly unbalanced values")
        
        
def logistic_fit(feature):
    
    import warnings
    warnings.filterwarnings("ignore", category=FutureWarning)
    
    from sklearn.metrics import accuracy_score
    from sklearn.metrics import precision_score
    from sklearn.metrics import recall_score
    from sklearn.metrics import f1_score
    from sklearn.metrics import r2_score

    if feature in train_sample.columns:
        
        from sklearn.linear_model import LogisticRegression
        
        f, axes = plt.subplots(1, 2, figsize=(21, 10))

        # test if there is a logistic relationship between the feature1 and the target.
        print()
        print("Fitting a logistic regression model for the feature", feature,"against the target variable")
        
               
        mask = ~train_sample[feature].isnull() & ~train_sample["HasDetections"].isnull()

        logmodel = LogisticRegression(C=1e5, solver='lbfgs')
        
        if feature in categorical_columns:        
            logmodel.fit(train_sample[feature][mask].cat.codes.values.reshape(-1,1), train_sample["HasDetections"][mask])
            predictions = logmodel.predict(train_sample[feature][mask].cat.codes.values.reshape(-1,1))
        else:
            logmodel.fit(train_sample[feature][mask].values.reshape(-1,1), train_sample["HasDetections"][mask])
            predictions = logmodel.predict(train_sample[feature][mask].values.reshape(-1,1))

        from sklearn.metrics import classification_report
        print(classification_report(train_sample["HasDetections"][mask], predictions))
        print("")
        print("accuracy score:", accuracy_score(train_sample["HasDetections"][mask], predictions))
        print("F1 score:", accuracy_score(train_sample["HasDetections"][mask], predictions))
        #print("R^2 score:", r2_score(train_sample["HasDetections"][mask], predictions))

        import scikitplot as skplt
        skplt.metrics.plot_confusion_matrix(train_sample["HasDetections"][mask], predictions, normalize=False,
                                            title = "Confusion matrix for the feature: "+feature+" against the target variable after fitting a logistic regression model",
                                           figsize=(10,8), text_fontsize='medium', cmap="BrBG", ax = axes[0])
        
        
        # import statsmodels.api as sm
        # print()
        # est = sm.Logit(train_sample["HasDetections"][mask], train_sample[feature][mask].cat.codes.values.reshape(-1,1))
        # result1=est.fit()
        # print(result1.summary())
        if feature in categorical_columns:
            axes[1] = plt.scatter(train_sample[feature][mask].cat.codes.values.reshape(-1,1), predictions)
            axes[1] = plt.scatter(train_sample[feature][mask].cat.codes.values.reshape(-1,1), logmodel.predict_proba(train_sample[feature][mask].cat.codes.values.reshape(-1,1))[:,1])
            plt.xlabel(feature)
            plt.ylabel("HasDetections Probability")
            plt.title("Probability of Detecting a Malware vs the "+ feature)
            plt.show()
        else:
            axes[1] = plt.scatter(train_sample[feature][mask].values.reshape(-1,1), predictions)
            axes[1] = plt.scatter(train_sample[feature][mask].values.reshape(-1,1), logmodel.predict_proba(train_sample[feature][mask].values.reshape(-1,1))[:,1])
            plt.xlabel(feature)
            plt.ylabel("HasDetections Probability")
            plt.title("Probability of Detecting a Malware vs the "+ feature)
            plt.show()
        
    else:
        print("This feature has been removed from dataset due to high NaN rate or highly unbalanced values")



# In[24]:


categorical_univariate_and_bivariate_stats(feature="ProductName")
logistic_fit(feature="ProductName")


# In[25]:


categorical_univariate_and_bivariate_stats(feature="EngineVersion")
logistic_fit(feature="EngineVersion")


# We can see that 2 engine versions, "1.1.15200.1" and "1.1.15100.1" is at high frequencies than the rest engine versions. However the version "1.1.15100.1" has more Malware Detections than the rest of the categoeris. Just out of curiosity, fitting a logistic regression for binary classification for this feature against the target variable, It detects the infected systems with precision. However the model is very weak due to its low accuracy and high recall scores, but it can at least predict the infected systems with great precision.

# In[26]:


categorical_univariate_and_bivariate_stats(feature="AppVersion")
logistic_fit(feature="AppVersion")


# In[27]:


categorical_univariate_and_bivariate_stats(feature="AvSigVersion")
logistic_fit(feature="AvSigVersion")


# In[28]:


categorical_univariate_and_bivariate_stats(feature="Platform")
logistic_fit(feature="Platform")


# In[29]:


categorical_univariate_and_bivariate_stats(feature="Processor")
logistic_fit(feature="Processor")


# In[30]:


categorical_univariate_and_bivariate_stats(feature="OsVer")
logistic_fit(feature="OsVer")


# In[31]:


categorical_univariate_and_bivariate_stats(feature="OsPlatformSubRelease")
logistic_fit(feature="OsPlatformSubRelease")


# In[32]:


categorical_univariate_and_bivariate_stats(feature="OsBuildLab")
logistic_fit(feature="OsBuildLab")


# In[33]:


categorical_univariate_and_bivariate_stats(feature="SmartScreen")
logistic_fit(feature="SmartScreen")


# In[34]:


categorical_univariate_and_bivariate_stats(feature="Census_MDC2FormFactor")
logistic_fit(feature="Census_MDC2FormFactor")


# In[35]:


categorical_univariate_and_bivariate_stats(feature="Census_ChassisTypeName")
logistic_fit(feature="Census_ChassisTypeName")


# In[36]:


categorical_univariate_and_bivariate_stats(feature="Census_PowerPlatformRoleName")
logistic_fit(feature="Census_PowerPlatformRoleName")


# In[37]:


categorical_univariate_and_bivariate_stats(feature="Census_InternalBatteryType")
logistic_fit(feature="Census_InternalBatteryType")


# In[38]:


categorical_univariate_and_bivariate_stats(feature="Census_OSVersion")
logistic_fit(feature="Census_OSVersion")


# In[39]:


categorical_univariate_and_bivariate_stats(feature="Census_OSArchitecture")
logistic_fit(feature="Census_OSArchitecture")


# In[40]:


categorical_univariate_and_bivariate_stats(feature="Census_OSBranch")
logistic_fit(feature="Census_OSBranch")


# In[41]:


categorical_univariate_and_bivariate_stats(feature="Census_OSEdition")
logistic_fit(feature="Census_OSEdition")


# In[42]:


categorical_univariate_and_bivariate_stats(feature="Census_OSSkuName")
logistic_fit(feature="Census_OSSkuName")


# In[43]:


categorical_univariate_and_bivariate_stats(feature="Census_OSInstallTypeName")
logistic_fit(feature="Census_OSInstallTypeName")


# In[44]:


categorical_univariate_and_bivariate_stats(feature="Census_OSWUAutoUpdateOptionsName")
logistic_fit(feature="Census_OSWUAutoUpdateOptionsName")


# In[45]:


categorical_univariate_and_bivariate_stats(feature="Census_GenuineStateName")
logistic_fit(feature="Census_GenuineStateName")


# In[46]:


categorical_univariate_and_bivariate_stats(feature="Census_ActivationChannel")
logistic_fit(feature="Census_ActivationChannel")


# In[47]:


categorical_univariate_and_bivariate_stats(feature="Census_FlightRing")
logistic_fit(feature="Census_FlightRing")


# In[48]:


gc.collect()


# ### Numerical Columns Univariate and Bivariate Plots against the taget variable
# 
# #### Inspecting each one of the numerical features from the train set and illustrating the top most occured values against the *HasDetections* target variable. Moreover trying to fit a logistic regression model between the target variable and the inspected feature to identify if the feature is a good predictor.

# In[49]:


numerical_and_binary_columns


# In[50]:


def numerical_univariate_and_bivariate_plot(feature, num_of_bins = 40):
    
    import warnings
    warnings.filterwarnings("ignore", category=FutureWarning)
    warnings.filterwarnings("ignore", category=RuntimeWarning)
    
    sns.set_style("darkgrid", {"axes.facecolor": ".9"})
    
    if feature in train_sample.columns:
    
        print("Top 10 Values counts for the numerical feature", feature)
        print(train_sample[feature].value_counts().head(10))
        print("Min value", train_sample[feature].min())
        print("Max value", train_sample[feature].max())
        print("NaN values", train_sample[feature].isnull().sum())
        print("Number of unique values", train_sample[feature].nunique())

        if train[feature].nunique() > 2:
            print("Mean value", train_sample[feature].mean())
            print("Variance value", train_sample[feature].var())

        # for binary features
        if train[feature].nunique() <= 2:

            f, axes = plt.subplots(1, 2, figsize=(21, 10))

            sns.countplot(x=feature, data=train_sample, ax=axes[0])
            sns.countplot(x=feature, hue = "HasDetections", data=train_sample, ax=axes[1], palette=['b','r'])
            
            f.suptitle("Numerical feature: "+feature+" Univariate and Bivariate plots against the target variable")

        # for numeric features
        else:

            f, axes = plt.subplots(1, 3, figsize=(21, 10))

            sns.distplot(train_sample[feature].dropna(), rug=False, kde=False, ax=axes[0], bins = num_of_bins)

            sns.violinplot(x="HasDetections", y = feature, hue="HasDetections", data=train_sample, ax=axes[1], palette=['b','r'])

            if feature == "LocaleEnglishNameIdentifier":
                sns.distplot(train_sample[train_sample["HasDetections"] == 0][feature].dropna().astype("int16"), rug=False, kde=False, color="b", ax=axes[2], bins = num_of_bins)
                sns.distplot(train_sample[train_sample["HasDetections"] == 1][feature].dropna().astype("int16"), rug=False, kde=False, color="r", ax=axes[2], bins = num_of_bins)
            else:
                sns.distplot(train_sample[train_sample["HasDetections"] == 0][feature].dropna(), rug=False, kde=False, color="b", ax=axes[2], bins = num_of_bins)
                sns.distplot(train_sample[train_sample["HasDetections"] == 1][feature].dropna(), rug=False, kde=False, color="r", ax=axes[2], bins = num_of_bins)
            
                f.suptitle("Numerical feature: "+feature+" Univariate and Bivariate plots against the target variable")
    else:
        print("This feature has been removed from dataset due to high NaN rate or highly unbalanced values")




# In[51]:


numerical_univariate_and_bivariate_plot(feature = "IsBeta")


# In[52]:


numerical_univariate_and_bivariate_plot(feature="RtpStateBitfield")
logistic_fit("RtpStateBitfield")


# In[53]:


numerical_univariate_and_bivariate_plot(feature="IsSxsPassiveMode")
logistic_fit("IsSxsPassiveMode")


# In[54]:


numerical_univariate_and_bivariate_plot(feature="AVProductStatesIdentifier")
logistic_fit("AVProductStatesIdentifier")


# In[55]:


numerical_univariate_and_bivariate_plot(feature="AVProductsInstalled")
logistic_fit("AVProductsInstalled")


# In[56]:


numerical_univariate_and_bivariate_plot("HasTpm")
logistic_fit("HasTpm")


# In[57]:


numerical_univariate_and_bivariate_plot("CountryIdentifier")
logistic_fit("CountryIdentifier")


# In[58]:


numerical_univariate_and_bivariate_plot("CityIdentifier")
logistic_fit("CityIdentifier")


# In[59]:


numerical_univariate_and_bivariate_plot("OrganizationIdentifier")
logistic_fit("OrganizationIdentifier")


# In[60]:


numerical_univariate_and_bivariate_plot("GeoNameIdentifier")
logistic_fit("GeoNameIdentifier")


# In[61]:


numerical_univariate_and_bivariate_plot("LocaleEnglishNameIdentifier")
logistic_fit("LocaleEnglishNameIdentifier")


# In[62]:


numerical_univariate_and_bivariate_plot("OsBuild")
logistic_fit("OsBuild")


# In[63]:


numerical_univariate_and_bivariate_plot("OsSuite")
logistic_fit("OsSuite")


# In[64]:


numerical_univariate_and_bivariate_plot("IsProtected")
logistic_fit("IsProtected")


# In[65]:


numerical_univariate_and_bivariate_plot("AutoSampleOptIn")
logistic_fit("AutoSampleOptIn")


# In[66]:


numerical_univariate_and_bivariate_plot("SMode")
logistic_fit("SMode")


# In[67]:


numerical_univariate_and_bivariate_plot("IeVerIdentifier")
logistic_fit("IeVerIdentifier")


# In[68]:


numerical_univariate_and_bivariate_plot("Firewall")
logistic_fit("Firewall")


# In[69]:


numerical_univariate_and_bivariate_plot("UacLuaenable")
logistic_fit("UacLuaenable")


# In[70]:


numerical_univariate_and_bivariate_plot("Census_OEMNameIdentifier")
logistic_fit("Census_OEMNameIdentifier")


# In[71]:


numerical_univariate_and_bivariate_plot("Census_OEMModelIdentifier")
logistic_fit("Census_OEMModelIdentifier")


# In[72]:


numerical_univariate_and_bivariate_plot("Census_ProcessorCoreCount")
logistic_fit("Census_ProcessorCoreCount")


# In[73]:


numerical_univariate_and_bivariate_plot("Census_ProcessorManufacturerIdentifier")
logistic_fit("Census_ProcessorManufacturerIdentifier")


# In[74]:


numerical_univariate_and_bivariate_plot("Census_ProcessorModelIdentifier")
logistic_fit("Census_ProcessorModelIdentifier")


# In[75]:


numerical_univariate_and_bivariate_plot("Census_PrimaryDiskTotalCapacity")
logistic_fit("Census_PrimaryDiskTotalCapacity")


# In[76]:


numerical_univariate_and_bivariate_plot("Census_SystemVolumeTotalCapacity")
logistic_fit("Census_SystemVolumeTotalCapacity")


# In[77]:


numerical_univariate_and_bivariate_plot("Census_HasOpticalDiskDrive")
logistic_fit("Census_HasOpticalDiskDrive")


# In[78]:


numerical_univariate_and_bivariate_plot("Census_TotalPhysicalRAM")
logistic_fit("Census_TotalPhysicalRAM")


# In[79]:


numerical_univariate_and_bivariate_plot("Census_InternalPrimaryDiagonalDisplaySizeInInches")
logistic_fit("Census_InternalPrimaryDiagonalDisplaySizeInInches")


# In[80]:


numerical_univariate_and_bivariate_plot("Census_InternalPrimaryDisplayResolutionHorizontal")
logistic_fit("Census_InternalPrimaryDisplayResolutionHorizontal")


# In[81]:


numerical_univariate_and_bivariate_plot("Census_InternalPrimaryDisplayResolutionVertical")
logistic_fit("Census_InternalPrimaryDisplayResolutionVertical")


# In[82]:


numerical_univariate_and_bivariate_plot("Census_InternalBatteryNumberOfCharges")
logistic_fit("Census_InternalBatteryNumberOfCharges")


# In[83]:


numerical_univariate_and_bivariate_plot("Census_OSBuildNumber")
logistic_fit("Census_OSBuildNumber")


# In[84]:


numerical_univariate_and_bivariate_plot("Census_OSBuildRevision")
logistic_fit("Census_OSBuildRevision")


# In[85]:


numerical_univariate_and_bivariate_plot("Census_OSInstallLanguageIdentifier")
logistic_fit("Census_OSInstallLanguageIdentifier")


# In[86]:


numerical_univariate_and_bivariate_plot("Census_OSUILocaleIdentifier")
logistic_fit("Census_OSUILocaleIdentifier")


# In[87]:


numerical_univariate_and_bivariate_plot("Census_IsPortableOperatingSystem")
logistic_fit("Census_IsPortableOperatingSystem")


# In[88]:


numerical_univariate_and_bivariate_plot("Census_IsFlightingInternal")
logistic_fit("Census_IsFlightingInternal")


# In[89]:


numerical_univariate_and_bivariate_plot("Census_IsFlightsDisabled")
logistic_fit("Census_IsFlightsDisabled")


# In[90]:


numerical_univariate_and_bivariate_plot("Census_ThresholdOptIn")
logistic_fit("Census_ThresholdOptIn")


# In[91]:


numerical_univariate_and_bivariate_plot("Census_FirmwareManufacturerIdentifier")
logistic_fit("Census_FirmwareManufacturerIdentifier")


# In[92]:


numerical_univariate_and_bivariate_plot("Census_FirmwareManufacturerIdentifier")
logistic_fit("Census_FirmwareManufacturerIdentifier")


# In[93]:


numerical_univariate_and_bivariate_plot("Census_FirmwareVersionIdentifier")
logistic_fit("Census_FirmwareVersionIdentifier")


# In[94]:


numerical_univariate_and_bivariate_plot("Census_IsSecureBootEnabled")
logistic_fit("Census_IsSecureBootEnabled")


# In[95]:


numerical_univariate_and_bivariate_plot("Census_IsWIMBootEnabled")
logistic_fit("Census_IsWIMBootEnabled")


# In[96]:


numerical_univariate_and_bivariate_plot("Census_IsVirtualDevice")
logistic_fit("Census_IsVirtualDevice")


# In[97]:


numerical_univariate_and_bivariate_plot("Census_IsTouchEnabled")
logistic_fit("Census_IsTouchEnabled")


# In[98]:


numerical_univariate_and_bivariate_plot("Census_IsPenCapable")
logistic_fit("Census_IsPenCapable")


# In[99]:


numerical_univariate_and_bivariate_plot("Census_IsAlwaysOnAlwaysConnectedCapable")
logistic_fit("Census_IsAlwaysOnAlwaysConnectedCapable")


# In[100]:


numerical_univariate_and_bivariate_plot("Wdft_IsGamer")
logistic_fit("Wdft_IsGamer")


# In[101]:


numerical_univariate_and_bivariate_plot("Wdft_RegionIdentifier")
logistic_fit("Wdft_RegionIdentifier")


# In[102]:


gc.collect()


# ### Correlations in Numerical Features
# Trying to find corellations between numerical features

# In[103]:


start_time = time.time()

sns.set(rc={'figure.figsize':(34.7,39.27)})

# Compute the correlation matrix
corr = train[numerical_and_binary_columns].corr()

# Generate a mask for the upper triangle
mask = np.zeros_like(corr, dtype=np.bool)
mask[np.triu_indices_from(mask)] = True

sns.heatmap(corr, mask=mask, annot=True, fmt=".2f", cmap='coolwarm')

print("elapsed time:", time.time() - start_time, "seconds")


# Data correlation is the way in which one set of data may correspond to another set. In ML, think of how your features correspond with your output.

# ### Most correlated features

# In[104]:


s = corr.unstack().drop_duplicates()
so = s.sort_values(kind="quicksort")

print("Top most highly megative correlated features:")
print(so[(so<-0.4)])
print()

print("Top most highly positive correlated features:")
print(so[(so<1) & (so>0.5)].sort_values(ascending=False))


# ### Delete Variables

# In[105]:


del corr
del mask
del s
del so
gc.collect()


# ### Multivariate - Trivariate Analysis between highly correlated features and against the target variable; "HasDetections".
# #### Inspecting the relationship between highly correlated features. Moreover trying to fit a logistic regression model between the target variable and the inspected features to identify if the features are good predictors.

# In[106]:


get_ipython().run_cell_magic('time', '', 'def multivariate_plot(feature1, feature2):\n    \n    import warnings\n    warnings.filterwarnings("ignore", category=FutureWarning)\n    \n    sns.set_style("darkgrid", {"axes.facecolor": ".9"})\n    \n    # check if one of the two features exists in train_sample columns\n    if (feature1 not in train_sample.columns) | (feature2 not in train_sample.columns):\n        if (feature1 not in train_sample.columns):\n            print(feature1, "has been removed due to high NA rate or highly unbalanced values")\n        elif (feature2 not in train_sample.columns):\n            print(feature2, "has been removed due to high NA rate or higlhy unbalanced values")\n        print()\n            \n    else:\n        \n        f, axes = plt.subplots(1, 2, figsize=(21, 10))\n        \n        # Due to overflow error I have to convert some columns into a bigger data type\n        if (feature1 == "LocaleEnglishNameIdentifier") & (feature2 == "Census_OSUILocaleIdentifier"):\n            g1 = sns.scatterplot(x=train_sample["LocaleEnglishNameIdentifier"].astype(\'int16\'), y=train_sample["Census_OSUILocaleIdentifier"], hue = train_sample["HasDetections"], ax = axes[0])\n            #g1 = sns.jointplot(x=train_sample["LocaleEnglishNameIdentifier"].astype(\'int16\'), y=train_sample["Census_OSUILocaleIdentifier"], height=9, data = train)\n            \n            plt.title(\'Scatterplot Between: \'+feature1+" and "+feature2, y=1.3, fontsize = 9)\n            \n        elif (feature1 == "LocaleEnglishNameIdentifier") & (feature2 == "Census_OSInstallLanguageIdentifier"):\n            g1 = sns.scatterplot(x=train_sample["LocaleEnglishNameIdentifier"].astype(\'float16\'), y=train_sample["Census_OSInstallLanguageIdentifier"], hue = train_sample["HasDetections"], ax = axes[0])\n            #g1 = sns.jointplot(x=train_sample["LocaleEnglishNameIdentifier"].astype(\'float16\'), y=train_sample["Census_OSInstallLanguageIdentifier"], height=9, data = train)\n            \n            plt.title(\'Scatterplot Between: \'+feature1+" and "+feature2, y=1.3, fontsize = 9)\n        else:    \n            g1 = sns.scatterplot(x=train_sample[feature1], y=train_sample[feature2], hue = train_sample["HasDetections"], ax = axes[0])\n            \n            axes[0].set_title(\'Scatterplot Between: \'+feature1+" and "+feature2)\n\n        #g2 = sns.lmplot(x=feature1, y=feature2, hue="HasDetections", n_boot=1, data = train_sample, height=9, markers=["o", "x"], palette=["b", "r"])\n        #g2 = sns.jointplot(x=feature1, y=feature2, data = train_sample, hue = "HasDetections", height=9)\n        #g2 = sns.scatterplot(x=feature1, y=feature2, data = train_sample, hue = "HasDetections")\n        \n        #plt.title(\'Scatterplot Between: \'+feature1+" and "+feature2+" against the target variable: \'HasDetections\'", y=1.1, fontsize = 16)\n        \n        \n        # fitting a logistic regression model with the 2 features\n        \n        # test if there is a logistic relationship between the feature1 and the target.\n        \n        from sklearn.metrics import accuracy_score\n        from sklearn.metrics import precision_score\n        from sklearn.metrics import recall_score\n        from sklearn.metrics import f1_score\n        from sklearn.metrics import r2_score\n        \n        from sklearn.linear_model import LogisticRegression\n        \n        print()\n        print("Fitting a logistic regression model for the features", feature1,"and",feature2,"against the target variable")\n        \n        mask = ~train_sample[feature1].isnull() & ~train_sample[feature2].isnull() & ~train_sample["HasDetections"].isnull()\n\n        logmodel = LogisticRegression()\n        \n        logmodel.fit(train_sample[[feature1, feature2]][mask].values, train_sample["HasDetections"][mask])\n        predictions = logmodel.predict(train_sample[[feature1, feature2]][mask].values)\n\n        from sklearn.metrics import classification_report\n        print(classification_report(train_sample["HasDetections"][mask], predictions))\n        print("")\n        print("accuracy score:", accuracy_score(train_sample["HasDetections"][mask], predictions))\n        print("F1 score:", accuracy_score(train_sample["HasDetections"][mask], predictions))\n        #print("R^2 score:", r2_score(train_sample["HasDetections"][mask], predictions))\n        \n        \n        g2 = sns.scatterplot(x=train_sample[feature1][mask].values, y=train_sample[feature2][mask].values, hue = predictions, ax=axes[1])\n        axes[1].set_title(\'Logistic Predictions Between: \'+feature1+" and "+feature2)\n\n        import scikitplot as skplt\n        skplt.metrics.plot_confusion_matrix(train_sample["HasDetections"][mask], predictions, normalize=False,\n                                            title = "Confusion matrix for two features: "+feature1+" and "+feature2+" against the target variable after fitting a logistic regression model",\n                                           figsize=(10,8), text_fontsize=\'large\', cmap="BrBG")\n        \n\n        #### my mistake, how can I fit a linear model for binary classification, I have to use here logistic regression as before :D\n        \n        # old code in comments\n        \'\'\'\n        ### test if a linear model will fit the 2 correlated feature against the target variable\n        # my thanks to: https://www.datasciencecentral.com/profiles/blogs/linear-regression-in-python-use-of-numpy-scipy-and-statsmodels\n        # this link helped me a lot https://stackoverflow.com/questions/13643363/linear-regression-of-arrays-containing-nans-in-python-numpy\n        \n        \n        # test if there is a linear relationship between the feature1 and the target.\n        from scipy import stats\n        mask = ~np.isnan(train_sample[feature1]) & ~np.isnan(train_sample["HasDetections"])\n        slope, intercept, r_value, p_value, std_err = stats.linregress(train_sample[feature1][mask], train_sample["HasDetections"][mask])\n\n        sign=\'+\'\n        if slope<0:\n            sign = \'\'\n        \n        lm_1 = "linear regression function #1: y = "+str(np.round(intercept,5))+" "+sign +" "+str(np.round(slope,5))+" * "+feature1\n        lm_1 = lm_1+"\\n"+" p-value: "+str(p_value)+"\\n"+" R^2: "+str(r_value)\n        #print(lm_1)\n        #print(feature1, "p-value",p_value)\n        #print("R^2:", r_value)\n\n        #print()\n\n        # test if there is a linear relationship between the feature2 and the target.\n        mask = ~np.isnan(train_sample[feature2]) & ~np.isnan(train_sample["HasDetections"])\n        slope, intercept, r_value, p_value, std_err = stats.linregress(train_sample[feature2][mask], train_sample["HasDetections"][mask])\n\n        sign=\'+\'\n        if slope<0:\n            sign=\'\'\n        \n        lm_2 = "linear regression function #2: y = "+str(np.round(intercept,5))+" "+sign +" "+str(np.round(slope,5))+" * "+feature2\n        lm_2 = lm_2+"\\n"+" p-value: "+str(p_value)+"\\n"+" R^2: "+str(r_value)\n        #print(lm_2)\n        #print(feature2, "p-value",p_value)\n        #print("R^2:", 100* r_value)\n        \n        plt.figure(figsize=(8, 9))\n        ax = plt.subplot(121)\n    \n        # plotting text with matplotlib:\n        # https://matplotlib.org/api/_as_gen/matplotlib.pyplot.text.html\n        plt.text(0.5, 0.9, lm_1, size=15, ha="center", va="center",\n         bbox=dict(boxstyle="round",\n                   ec=(1., 0.5, 0.5),\n                   fc=(1., 0.8, 0.8),\n                   )\n         )\n        \n        \n        plt.text(0.5, 0.6, lm_2, size=15, ha="center", va="center",\n         bbox=dict(boxstyle="round",\n                   ec=(1., 0.5, 0.5),\n                   fc=(1., 0.8, 0.8),\n                   )\n         )\n\n        plt.axis(\'off\')\n        plt.show()\n        \'\'\'\n\n    \n')


# In[107]:


get_ipython().run_cell_magic('time', '', 'multivariate_plot("RtpStateBitfield", "IsSxsPassiveMode")\ngc.collect()\n')


# In[108]:


get_ipython().run_cell_magic('time', '', 'multivariate_plot("AVProductStatesIdentifier", "AVProductsInstalled")\ngc.collect()\n')


# In[109]:


get_ipython().run_cell_magic('time', '', 'multivariate_plot("Census_OSBuildNumber", "Census_OSBuildRevision")\ngc.collect()\n')


# In[110]:


get_ipython().run_cell_magic('time', '', 'multivariate_plot("OsBuild", "Census_OSBuildRevision")\ngc.collect()\n')


# In[111]:


get_ipython().run_cell_magic('time', '', 'multivariate_plot("HasTpm", "IeVerIdentifier")\ngc.collect()\n')


# In[112]:


get_ipython().run_cell_magic('time', '', 'multivariate_plot("LocaleEnglishNameIdentifier", "Census_OSUILocaleIdentifier")\ngc.collect()\n')


# In[113]:


get_ipython().run_cell_magic('time', '', 'multivariate_plot("Census_InternalBatteryNumberOfCharges", "Census_FirmwareManufacturerIdentifier")\ngc.collect()\n')


# In[114]:


get_ipython().run_cell_magic('time', '', 'multivariate_plot("LocaleEnglishNameIdentifier", "Census_OSInstallLanguageIdentifier")\ngc.collect()\n')


# In[115]:


get_ipython().run_cell_magic('time', '', 'multivariate_plot("Census_OEMModelIdentifier", "Census_FirmwareManufacturerIdentifier")\ngc.collect()\n')


# In[116]:


get_ipython().run_cell_magic('time', '', 'multivariate_plot("Census_OEMNameIdentifier", "Census_FirmwareVersionIdentifier")\ngc.collect()\n')


# <a id="ML"></a>
# ## Machine Learning modeling

# ![](https://cmci.colorado.edu/classes/INFO-4604/fa17/wordcloud.png)
# 
# As we saw, linear relationships are really weak, thus Classification Trees will find patterns of relations between the target variable with the features.

# ### Delete Train set, to free up memory space.

# In[117]:


del train
gc.collect()


# ### Reading the test data

# In[118]:


test_dtypes = {k: v for k, v in dtypes.items() if k in good_cols}

# get all columns except
test = pd.read_csv('../input/test.csv', dtype=test_dtypes, usecols=good_cols[:-1])

#test = reduce_mem_usage(test)


# In[119]:


test.head()


# In[120]:


test.shape


# ### Feature Engineering

# In[121]:


new = train_sample["OsBuildLab"].str.split(".", expand = True)
train_sample["OsBuildLab_1"] = new[2]

new = test["OsBuildLab"].str.split(".", expand = True)
test["OsBuildLab_1"] = new[2]


categorical_columns.append("OsBuildLab_1")
del new

#special thanks to https://www.kaggle.com/delayedkarma/let-s-add-some-new-features-lb-0-674

#train_sample['new_num_1'] = train_sample['Census_TotalPhysicalRAM'] * train_sample['Census_InternalPrimaryDiagonalDisplaySizeInInches']
#test['new_num_1'] = test['Census_TotalPhysicalRAM'] * test['Census_InternalPrimaryDiagonalDisplaySizeInInches']

#train_sample['new_num_2'] = train_sample['Census_ProcessorCoreCount'] * train_sample['Census_InternalPrimaryDiagonalDisplaySizeInInches']
#test['new_num_2'] = test['Census_ProcessorCoreCount'] * test['Census_InternalPrimaryDiagonalDisplaySizeInInches']

#train_sample['new_num_3'] = train_sample['Census_ProcessorCoreCount'] * train_sample['Census_TotalPhysicalRAM']
#test['new_num_3'] = test['Census_ProcessorCoreCount'] * test['Census_TotalPhysicalRAM']

#train_sample['new_num_4'] = train_sample['Census_PrimaryDiskTotalCapacity'] * train_sample['Census_TotalPhysicalRAM']
#test['new_num_4'] = test['Census_PrimaryDiskTotalCapacity'] * test['Census_TotalPhysicalRAM']

#train_sample['new_num_5'] = train_sample['Census_SystemVolumeTotalCapacity'] * train_sample['Census_InternalPrimaryDiagonalDisplaySizeInInches']
#test['new_num_5'] = test['Census_SystemVolumeTotalCapacity'] * test['Census_InternalPrimaryDiagonalDisplaySizeInInches']


# ### Drop the unique "MachineIdentifier" Identifiers

# In[122]:


train_sample = train_sample.drop(['MachineIdentifier'], axis=1)
test = test.drop(['MachineIdentifier'], axis=1)


# In[123]:


train_sample = train_sample.reset_index(drop=True)


# ### Filling NA values with the statistical Mode

# In[124]:


modes = train_sample.mode()

for col in train_sample.columns:
    train_sample[col] = np.where(train_sample[col].isnull(), modes[col], train_sample[col])

del modes


# In[125]:


modes_test = test.mode()

for col in test.columns:
    test[col] = np.where(test[col].isnull(), modes_test[col], test[col])

#train_sample.shape
del modes_test


# ### Concatenate both train_sample and test sets before label encoding

# In[126]:


train_shape = train_sample.shape
test_shape = test.shape

train_and_test = pd.concat([train_sample,test], axis="rows", sort=False)

del train_sample
del test
gc.collect()


# In[127]:


train_and_test.head()


# In[128]:


train_and_test.tail()


# ### Encode the Categorical features before machine learning modeling

# In[129]:


from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import OneHotEncoder

def MultiLabelEncoder(columnlist,dataframe):
    for i in columnlist:
        #print(i)
        labelencoder_X=LabelEncoder()
        dataframe[i]=labelencoder_X.fit_transform(dataframe[i])

MultiLabelEncoder(categorical_columns, train_and_test)


# In[130]:


gc.collect()


# ### Auto Feature Engineering ** (requires a lot of memory.... :( ) **

# In[131]:


#import featuretools as ft

# creating and entity set 'es'
#es = ft.EntitySet(id = 'es_id')

# adding a dataframe 
#es.entity_from_dataframe(entity_id = 'train_and_test_id', dataframe = train_and_test[numerical_columns[0:5]], index = 'id')

#feature_matrix, feature_names = ft.dfs(entityset=es, target_entity = 'train_and_test_id', chunk_size=.001, max_depth=2, verbose = 1, n_jobs = 3)


# In[132]:


#feature_matrix.columns


# In[133]:


#feature_matrix.head()


# ### Back to train and test set after Label Encoding

# In[134]:


train_sample = train_and_test[0:train_shape[0]]
test = train_and_test[(train_shape[0]):(train_and_test.shape[0]+1)]


# In[135]:


del train_and_test


# ### Remove the HasDetections columns from test set, it has been added during dataframe concatenation.

# In[136]:


test = test.drop(["HasDetections"], axis = 1)


# In[137]:


y = train_sample['HasDetections']
X = train_sample.drop(['HasDetections'], axis=1)


# In[138]:


del train_sample
gc.collect()


# ### XGBoost Tuned model with 70 / 30 train-valid split

# In[139]:


from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import f1_score
from sklearn.metrics import classification_report
from sklearn.metrics import roc_auc_score
import time

# create a 70/30 split of the data 
xtrain, xvalid, ytrain, yvalid = train_test_split(X, y, random_state=42, test_size=0.3)

import xgboost as xgb

start_time = time.time()

# special thanks to https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/
# these parameters have been found via xgboost tuning, you can see my tries in the commented tuning python snippets below:
# unfortunately it takes so much time to tune and to produce the final optimal classifier due to 9h time limit in Kaggle kernels.
clf_xgb = xgb.XGBClassifier(learning_rate=0.03, 
                            n_estimators=3000, 
                            max_depth=11,
                            min_child_weight=9,
                            gamma=0.2,
                            subsample=1,
                            colsample_bytree=0.4,
                            objective= 'binary:logistic',
                            nthread=-1,
                            scale_pos_weight=1,
                            reg_alpha = 0.6,
                            reg_lambda = 3,
                            seed=42)

clf_xgb.fit(xtrain, ytrain, eval_set=[(xtrain, ytrain), (xvalid, yvalid)], 
            early_stopping_rounds=100, eval_metric='auc', verbose=100)

predictions = clf_xgb.predict(xvalid)

print()
print(classification_report(yvalid, predictions))

print()
print("accuracy_score", accuracy_score(yvalid, predictions))

print()
predictions_probas = clf_xgb.predict_proba(xvalid)
print("roc-auc score for the class 1, from target 'HasDetections' ", roc_auc_score(yvalid, predictions_probas[:,1]))

print()
print("elapsed time in seconds: ", time.time() - start_time)

print()
gc.collect()


# In[140]:


from sklearn.metrics import confusion_matrix
import scikitplot as skplt

sns.set(rc={'figure.figsize':(8,8)})
skplt.metrics.plot_confusion_matrix(yvalid, predictions, cmap="BrBG")


# In[141]:


sns.set(rc={'figure.figsize':(8,8)})
skplt.metrics.plot_roc(yvalid, predictions_probas)


# In[142]:


sns.set(rc={'figure.figsize':(8,8)})
skplt.metrics.plot_ks_statistic(yvalid, predictions_probas)


# In[143]:


sns.set(rc={'figure.figsize':(8,8)})
skplt.metrics.plot_precision_recall(yvalid, predictions_probas)


# In[144]:


sns.set(rc={'figure.figsize':(8,8)})
skplt.metrics.plot_cumulative_gain(yvalid, predictions_probas)


# In[145]:


sns.set(rc={'figure.figsize':(8,8)})
skplt.metrics.plot_lift_curve(yvalid, predictions_probas)


# In[146]:


sns.set(rc={'figure.figsize':(12, 18)})
xgb.plot_importance(clf_xgb, title='Feature importance', xlabel='F score', ylabel='Features')


# In[147]:


gc.collect()


# ### Delete defined variables to free up memory space

# In[148]:


del X
del y
del xvalid
del yvalid
del xtrain
del ytrain
del predictions
del predictions_probas


# In[149]:


gc.collect()


# ### Make predictions for the test Set
# - Due to memory limitations predictions will be performed in chunks

# In[150]:


predictions_proba_test_list = []

chunck = 400000
test_times = test.shape[0] // chunck
test_rest = test.shape[0] % chunck

for i in  np.arange(0,(chunck * (test_times+1)), chunck):
    predictions_proba_test = list(clf_xgb.predict_proba(test[i:(i+chunck)])[:,1])
    predictions_proba_test_list.append(predictions_proba_test)
    #print("times:", i)


# flatten the list of lists
predictions_proba_test_list = [y for x in predictions_proba_test_list for y in x]

print(np.shape(predictions_proba_test_list))
print(test.shape)
gc.collect()


# ### Prepare Submission File

# In[151]:


del test


# In[152]:


del clf_xgb


# In[153]:


submission = pd.read_csv('../input/sample_submission.csv')
submission['HasDetections'] = predictions_proba_test_list
submission.to_csv('xgboost.csv', index=False)


# ## Conclusion
# This dataset is fun to work with due to Kaggle's memory restrictions. Both EDA and Machine Learning have a wide area for applications with the dataset due to the variety of different types of categorical and numerical features.

# ___________________________________

# In[154]:




